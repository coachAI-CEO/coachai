import { generatePromptForPlan } from "./prompts";
import { enrichDrill } from "./enrichDrill";
import { runPlanAI } from "./providerRouter";
import { loadGameModel } from "@/lib/game-models";
import { parsePlanJson } from "./parsePlan";
import { RICH_PLAN_FORMAT_HINT } from "./rich-format-hint";
import { normalizePlan } from "./normalizePlan";

export async function generatePlan(input: {
  phase: string;
  zone: string;
  age: string;
  goalsAvailable?: number;
  principles?: string[];
  psychThemes?: string[];
  model?: "POSSESSION" | "PRESSING" | "TRANSITION" | "COACHAI";
  totalDurationMin?: number;
}) {
  // --- Load the correct model (defaults to CoachAI Balanced)
  const gm = await loadGameModel(input.model || "COACHAI");

  const modelContext = {
    id: gm.id,
    name: gm.name,
    philosophy: gm.philosophy,
    globalPrinciples: gm.globalPrinciples,
    agePolicies: gm.agePolicies,
    sessionGuidelines: gm.sessionGuidelines,
    planningNotes: gm.prompts?.planningNotes,
  };

  // --- Build prompt & append rich-format hint
  let prompt = generatePromptForPlan({ ...input, modelContext });
  prompt += "\n" + RICH_PLAN_FORMAT_HINT;

  // --- Run model provider (Claude/Gemini)
  const text = await runPlanAI(prompt);

  // --- Parse into JSON & normalize for UI
  const rawObj = parsePlanJson(text);
  
const canonical = normalizePlan(rawObj);
const canonical = normalizePlan(rawObj, input.totalDurationMin, text);

  
  if (Array.isArray(canonical.segments)) {
    for (const seg of canonical.segments) {
      if (seg && seg.drill) {
        const needs = !seg.drill.modelInfluence;
        if (needs) {
          seg.drill = await enrichDrill(seg.drill, {
            phase: input.phase,
            zone: input.zone,
            age: input.age,
            model: {
              id: gm.id,
              name: gm.name,
              philosophy: gm.philosophy,
              principles: gm.globalPrinciples
            }
          });
        }
      }
    }
  }
// --- Enrich drills if missing organization/progression
  if (Array.isArray(canonical.segments)) {
    for (const seg of canonical.segments) {
      if (seg && seg.drill) {
        const needs =
          !seg.drill.organization ||
          !seg.drill.progression ||
          !seg.drill.setup ||
          !Array.isArray(seg.drill.coachingPoints) ||
          seg.drill.coachingPoints.length < 4;
        if (needs) {
          seg.drill = await enrichDrill(seg.drill, {
            phase: input.phase,
            zone: input.zone,
            age: input.age,
            model: {
              id: gm.id,
              name: gm.name,
              philosophy: gm.philosophy,
              principles: gm.globalPrinciples
            }
          });
        }
      }
    }
  }

  // --- Ensure summary exists
  if (!canonical.summary) {
    const firstLine = String(canonical.rationale || "").split(/\n+/)[0].trim();
    canonical.summary =
      firstLine || "Session overview: structured plan generated by CoachAI.";
  }

  // --- Fill any missing baseline drill data
  for (const seg of canonical.segments || []) {
    if (!seg.drill) continue;
    seg.drill = {
      title: seg.drill.title ?? seg.title,
      objective: seg.drill.objective ?? "",
      setup:
        seg.drill.setup ??
        "Mark out grid with cones. Explain objectives clearly.",
      equipment: seg.drill.equipment ?? ["balls", "cones", "bibs"],
      coachingPoints:
        seg.drill.coachingPoints ?? [
          "Emphasize correct body shape",
          "Encourage constant communication",
        ],
      technicalFocus: seg.drill.technicalFocus ?? ["positioning", "timing"],
      psychFocus: seg.drill.psychFocus ?? ["focus", "resilience"],
      organization: seg.drill.organization ?? null,
      progression: seg.drill.progression ?? null,
    };
  }

    // --- Ensure modelInfluence exists for all drills
  if (Array.isArray(canonical.segments)) {
    for (const seg of canonical.segments) {
      const d = seg && seg.drill;
      if (!d) continue;
      if (!d.modelInfluence) {
        d.modelInfluence = {
          modelName: gm.name,
          principlesApplied: ["compactness","delay","cover"],
          tacticalCues: [
            "Nearest presses, second covers, third balances",
            "Show outside when possible",
            "Recover behind the ball on loss",
          ],
          unitFocus: (String(input.zone||"").includes("DEFENSIVE") ? "Back line + DM" : "Unit"),
          intensityProfile: "moderate",
          scoringBias: "Defensive success: force wide, block, regain",
          constraintsToApply: [
            "Touch limit for attackers",
            "Bonus if defending team forces play wide",
            "Regain within 6s = extra point",
          ],
          coachingLanguage: ["Delay","Cover","Compact","Show wide"],
        };
      }
    }
  }

  return fillPlan(canonical, input, gm);
}
